
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>porespy.filters._funcs &#8212; PoreSpy  documentation</title>
<script>
  document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
  document.documentElement.dataset.theme = localStorage.getItem("theme") || "light"
</script>

  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=92025949c220c2e29695" rel="stylesheet">
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=92025949c220c2e29695" rel="stylesheet">


  <link rel="stylesheet"
    href="../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/custom.css" />

  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=92025949c220c2e29695">

    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/clipboard.min.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    <script src="../../../_static/design-tabs.js"></script>
    <script src="../../../_static/js/custom.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="docsearch:language" content="en">
  </head>
  
  
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="180" data-default-mode="">
    <div class="bd-header-announcement container-fluid" id="banner">
      

    </div>

    
    <nav class="bd-header navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="bd-header__inner container-xl">

  <div id="navbar-start">
    
    
  


<a class="navbar-brand logo" href="../../../index.html">
  
  
  
  
    <img src="../../../_static/porespy_logo.png" class="logo__image only-light" alt="Logo image">
    <img src="../../../_static/porespy_logo.png" class="logo__image only-dark" alt="Logo image">
  
  
</a>
    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="fas fa-bars"></span>
  </button>

  
  <div id="navbar-collapsible" class=" collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../installation.html">
  Installation
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../basic_usage.html">
  Basic Usage
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../modules/index.html">
  Module and Function Reference
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../_examples/index.html">
  Examples
 </a>
</li>

    
    <li class="nav-item">
        <a class="nav-link nav-external" href="https://github.com/PMEAL/porespy/issues">Issue Tracker<i class="fas fa-external-link-alt"></i></a>
    </li>
    
    <li class="nav-item">
        <a class="nav-link nav-external" href="https://github.com/PMEAL/porespy/discussions">Get Help<i class="fas fa-external-link-alt"></i></a>
    </li>
    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <span id="theme-switch" class="btn btn-sm btn-outline-primary navbar-btn rounded-circle">
    <a class="theme-switch" data-mode="light"><i class="fas fa-sun"></i></a>
    <a class="theme-switch" data-mode="dark"><i class="far fa-moon"></i></a>
    <a class="theme-switch" data-mode="auto"><i class="fas fa-adjust"></i></a>
</span>
      </div>
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Quick Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/PMEAL/porespy" rel="noopener" target="_blank" title="GitHub"><span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://twitter.com/porespy" rel="noopener" target="_blank" title="Twitter"><span><i class="fab fa-twitter-square"></i></span>
            <label class="sr-only">Twitter</label></a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="bd-container container-xl">
      <div class="bd-container__inner row">
          

<!-- Only show if we have sidebars configured, else just a small margin  -->
<div class="bd-sidebar-primary col-12 col-md-3 bd-sidebar">
  <div class="sidebar-start-items"><form class="bd-search d-flex align-items-center" action="../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
  </div>
</nav>
  </div>
  <div class="sidebar-end-items">
  </div>
</div>


          


<div class="bd-sidebar-secondary d-none d-xl-block col-xl-2 bd-toc">
  
</div>


          
          
          <div class="bd-content col-12 col-md-9 col-xl-7">
              
              <article class="bd-article" role="main">
                
  <h1>Source code for porespy.filters._funcs</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">inspect</span> <span class="k">as</span> <span class="nn">insp</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">dask</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">edt</span> <span class="kn">import</span> <span class="n">edt</span>
<span class="kn">import</span> <span class="nn">operator</span> <span class="k">as</span> <span class="nn">op</span>
<span class="kn">import</span> <span class="nn">scipy.ndimage</span> <span class="k">as</span> <span class="nn">spim</span>
<span class="kn">from</span> <span class="nn">deprecated</span> <span class="kn">import</span> <span class="n">deprecated</span>
<span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">reconstruction</span>
<span class="kn">from</span> <span class="nn">skimage.segmentation</span> <span class="kn">import</span> <span class="n">clear_border</span>
<span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">ball</span><span class="p">,</span> <span class="n">disk</span><span class="p">,</span> <span class="n">square</span><span class="p">,</span> <span class="n">cube</span><span class="p">,</span> <span class="n">diamond</span><span class="p">,</span> <span class="n">octahedron</span>
<span class="kn">from</span> <span class="nn">porespy.tools</span> <span class="kn">import</span> <span class="n">_check_for_singleton_axes</span>
<span class="kn">from</span> <span class="nn">porespy.tools</span> <span class="kn">import</span> <span class="n">get_border</span><span class="p">,</span> <span class="n">subdivide</span><span class="p">,</span> <span class="n">recombine</span><span class="p">,</span> <span class="n">make_contiguous</span>
<span class="kn">from</span> <span class="nn">porespy.tools</span> <span class="kn">import</span> <span class="n">unpad</span><span class="p">,</span> <span class="n">extract_subsection</span>
<span class="kn">from</span> <span class="nn">porespy.tools</span> <span class="kn">import</span> <span class="n">ps_disk</span><span class="p">,</span> <span class="n">ps_ball</span><span class="p">,</span> <span class="n">ps_round</span>
<span class="kn">from</span> <span class="nn">porespy</span> <span class="kn">import</span> <span class="n">settings</span>
<span class="kn">from</span> <span class="nn">porespy.tools</span> <span class="kn">import</span> <span class="n">get_tqdm</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;apply_chords&quot;</span><span class="p">,</span>
    <span class="s2">&quot;apply_chords_3D&quot;</span><span class="p">,</span>
    <span class="s2">&quot;apply_padded&quot;</span><span class="p">,</span>
    <span class="s2">&quot;chunked_func&quot;</span><span class="p">,</span>
    <span class="s2">&quot;distance_transform_lin&quot;</span><span class="p">,</span>
    <span class="s2">&quot;fill_blind_pores&quot;</span><span class="p">,</span>
    <span class="s2">&quot;find_disconnected_voxels&quot;</span><span class="p">,</span>
    <span class="s2">&quot;find_trapped_regions&quot;</span><span class="p">,</span>
    <span class="s2">&quot;find_dt_artifacts&quot;</span><span class="p">,</span>
    <span class="s2">&quot;flood&quot;</span><span class="p">,</span>
    <span class="s2">&quot;flood_func&quot;</span><span class="p">,</span>
    <span class="s2">&quot;hold_peaks&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ibip&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ibip_gpu&quot;</span><span class="p">,</span>
    <span class="s2">&quot;local_thickness&quot;</span><span class="p">,</span>
    <span class="s2">&quot;nphase_border&quot;</span><span class="p">,</span>
    <span class="s2">&quot;porosimetry&quot;</span><span class="p">,</span>
    <span class="s2">&quot;prune_branches&quot;</span><span class="p">,</span>
    <span class="s2">&quot;region_size&quot;</span><span class="p">,</span>
    <span class="s2">&quot;trim_disconnected_blobs&quot;</span><span class="p">,</span>
    <span class="s2">&quot;trim_extrema&quot;</span><span class="p">,</span>
    <span class="s2">&quot;trim_floating_solid&quot;</span><span class="p">,</span>
    <span class="s2">&quot;trim_nonpercolating_paths&quot;</span><span class="p">,</span>
    <span class="s2">&quot;trim_small_clusters&quot;</span><span class="p">,</span>
<span class="p">]</span>


<span class="n">tqdm</span> <span class="o">=</span> <span class="n">get_tqdm</span><span class="p">()</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="ibip"><a class="viewcode-back" href="../../../modules/generated/generated/porespy.filters.ibip.html#porespy.filters.ibip">[docs]</a><span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;The ibip function will be moved to the&quot;</span>
            <span class="o">+</span> <span class="s2">&quot; ``simulations`` module in a future version&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">ibip</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function has been moved to the ``simulations`` module, please use that.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">porespy.simulations</span> <span class="kn">import</span> <span class="n">ibip</span>
    <span class="k">return</span> <span class="n">ibip</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="ibip_gpu"><a class="viewcode-back" href="../../../modules/generated/generated/porespy.filters.ibip_gpu.html#porespy.filters.ibip_gpu">[docs]</a><span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;The ibip_gpu function will be moved to the&quot;</span>
            <span class="o">+</span> <span class="s2">&quot; ``simulations`` module in a future version&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">ibip_gpu</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function has been moved to the ``simulations`` module, please use that.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">porespy.simulations</span> <span class="kn">import</span> <span class="n">ibip_gpu</span>
    <span class="k">return</span> <span class="n">ibip_gpu</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="find_trapped_regions"><a class="viewcode-back" href="../../../modules/generated/generated/porespy.filters.find_trapped_regions.html#porespy.filters.find_trapped_regions">[docs]</a><span class="k">def</span> <span class="nf">find_trapped_regions</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">outlets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">return_mask</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the trapped regions given an invasion sequence image</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    seq : ndarray</span>
<span class="sd">        An image with invasion sequence values in each voxel.  Regions</span>
<span class="sd">        labelled -1 are considered uninvaded, and regions labelled 0 are</span>
<span class="sd">        considered solid.</span>
<span class="sd">    outlets : ndarray, optional</span>
<span class="sd">        An image the same size as ``seq`` with ``True`` indicating outlets</span>
<span class="sd">        and ``False`` elsewhere.  If not given then all image boundaries</span>
<span class="sd">        are considered outlets.</span>
<span class="sd">    bins : int</span>
<span class="sd">        The resolution to use when thresholding the ``seq`` image.  By default</span>
<span class="sd">        the invasion sequence will be broken into 25 discrete steps and</span>
<span class="sd">        trapping will be identified at each step. A higher value of ``bins``</span>
<span class="sd">        will provide a more accurate trapping analysis, but is more time</span>
<span class="sd">        consuming. If ``None`` is specified, then *all* the steps will</span>
<span class="sd">        analyzed, providing the highest accuracy.</span>
<span class="sd">    return_mask : bool</span>
<span class="sd">        If ``True`` (default) then the returned image is a boolean mask</span>
<span class="sd">        indicating which voxels are trapped.  If ``False``, then a copy of</span>
<span class="sd">        ``seq`` is returned with the trapped voxels set to uninvaded and</span>
<span class="sd">        the invasion sequence values adjusted accordingly.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    trapped : ND-image</span>
<span class="sd">        An image, the same size as ``seq``.  If ``return_mask`` is ``True``,</span>
<span class="sd">        then the image has ``True`` values indicating the trapped voxels.  If</span>
<span class="sd">        ``return_mask`` is ``False``, then a copy of ``seq`` is returned with</span>
<span class="sd">        trapped voxels set to 0.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    `Click here</span>
<span class="sd">    &lt;https://porespy.org/examples/filters/reference/find_trapped_regions.html&gt;`_</span>
<span class="sd">    to view online example.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">seq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">outlets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">outlets</span> <span class="o">=</span> <span class="n">get_border</span><span class="p">(</span><span class="n">seq</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;faces&#39;</span><span class="p">)</span>
    <span class="n">trapped</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">outlets</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">bins</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">seq</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="n">bins</span><span class="p">[</span><span class="n">bins</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="c1"># starting the max_bin at: minimum sequence at outlets</span>
        <span class="c1"># This means soon as the fluid reaches the outlets</span>
        <span class="c1"># outlet_seq = np.setdiff1d(seq[outlets], np.array([0]))</span>
        <span class="c1"># bins_start = outlet_seq.min()</span>
        <span class="c1"># starting the max_bin at: maximum sequence available</span>
        <span class="c1"># in the image. No matter if it&#39;s after percolation</span>
        <span class="c1"># threshold (reaching the outlets):</span>
        <span class="n">bins_start</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">bins_start</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="o">**</span><span class="n">settings</span><span class="o">.</span><span class="n">tqdm</span><span class="p">):</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">seq</span> <span class="o">&gt;=</span> <span class="n">i</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">spim</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">temp</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">outlets</span><span class="p">])</span>
        <span class="c1"># In cases where entire outlet is filled, the</span>
        <span class="c1"># first indice is not necessarily the</span>
        <span class="c1"># void space. Only the element with value</span>
        <span class="c1"># of zero needs to be removed, if it&#39;s in keep.</span>
        <span class="n">keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">keep</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">trapped</span> <span class="o">+=</span> <span class="n">temp</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">keep</span><span class="p">,</span> <span class="n">invert</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_mask</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">trapped</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">seq</span><span class="p">[</span><span class="n">trapped</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="n">make_contiguous</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;symmetric&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">seq</span></div>


<div class="viewcode-block" id="apply_padded"><a class="viewcode-back" href="../../../modules/generated/generated/porespy.filters.apply_padded.html#porespy.filters.apply_padded">[docs]</a><span class="k">def</span> <span class="nf">apply_padded</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">pad_val</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies padding to an image before sending to ``func``, then extracts</span>
<span class="sd">    the result corresponding to the original image shape.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im : ndarray</span>
<span class="sd">        The image to which ``func`` should be applied</span>
<span class="sd">    pad_width : int or list of ints</span>
<span class="sd">        The amount of padding to apply to each axis. Refer to</span>
<span class="sd">        ``numpy.pad`` documentation for more details.</span>
<span class="sd">    pad_val : scalar</span>
<span class="sd">        The value to place into the padded voxels.  The default is 1 (or</span>
<span class="sd">        ``True``) which extends the pore space.</span>
<span class="sd">    func : function handle</span>
<span class="sd">        The function to apply to the padded image.</span>
<span class="sd">    kwargs</span>
<span class="sd">        Additional keyword arguments are collected and passed to ``func``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    A use case for this is when using ``skimage.morphology.skeletonize_3d``</span>
<span class="sd">    to ensure that the skeleton extends beyond the edges of the image.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    `Click here</span>
<span class="sd">    &lt;https://porespy.org/examples/filters/reference/apply_padded.html&gt;`_</span>
<span class="sd">    to view online example.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">padded</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">pad_width</span><span class="o">=</span><span class="n">pad_width</span><span class="p">,</span>
                    <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="n">pad_val</span><span class="p">)</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">padded</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">unpad</span><span class="p">(</span><span class="n">im</span><span class="o">=</span><span class="n">temp</span><span class="p">,</span> <span class="n">pad_width</span><span class="o">=</span><span class="n">pad_width</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="trim_small_clusters"><a class="viewcode-back" href="../../../modules/generated/generated/porespy.filters.trim_small_clusters.html#porespy.filters.trim_small_clusters">[docs]</a><span class="k">def</span> <span class="nf">trim_small_clusters</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove isolated voxels or clusters of a given size or smaller</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im : ndarray</span>
<span class="sd">        The binary image from which voxels are to be removed.</span>
<span class="sd">    size : scalar</span>
<span class="sd">        The threshold size of clusters to trim.  As clusters with this</span>
<span class="sd">        many voxels or fewer will be trimmed.  The default is 1 so only</span>
<span class="sd">        single voxels are removed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    im : ndarray</span>
<span class="sd">        A copy of ``im`` with clusters of voxels smaller than the given</span>
<span class="sd">        ``size`` removed.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    `Click here</span>
<span class="sd">    &lt;https://porespy.org/examples/filters/reference/trim_small_clusters.html&gt;`_</span>
<span class="sd">    to view online example.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">strel</span> <span class="o">=</span> <span class="n">ps_round</span><span class="p">(</span><span class="n">r</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="n">im</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">filtered_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
    <span class="n">labels</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">spim</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">filtered_array</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">strel</span><span class="p">)</span>
    <span class="n">id_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">spim</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="n">area_mask</span> <span class="o">=</span> <span class="n">id_sizes</span> <span class="o">&lt;=</span> <span class="n">size</span>
    <span class="n">filtered_array</span><span class="p">[</span><span class="n">area_mask</span><span class="p">[</span><span class="n">labels</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">filtered_array</span></div>


<div class="viewcode-block" id="hold_peaks"><a class="viewcode-back" href="../../../modules/generated/generated/porespy.filters.hold_peaks.html#porespy.filters.hold_peaks">[docs]</a><span class="k">def</span> <span class="nf">hold_peaks</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Replaces each voxel with the highest value along the given axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im : ndarray</span>
<span class="sd">        A greyscale image whose peaks are to be found.</span>
<span class="sd">    axis : int</span>
<span class="sd">        The axis along which the operation is to be applied.</span>
<span class="sd">    ascending : bool</span>
<span class="sd">        If ``True`` (default) the given ``axis`` is scanned from 0 to end.</span>
<span class="sd">        If ``False``, it is scanned in reverse order from end to 0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : ndarray</span>
<span class="sd">        A copy of ``im`` with each voxel is replaced with the highest value along</span>
<span class="sd">        the given axis.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    &quot;im&quot; must be a greyscale image. In case a Boolean image is fed into this</span>
<span class="sd">    method, it will be converted to float values [0.0,1.0] before proceeding.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    `Click here</span>
<span class="sd">    &lt;https://porespy.org/examples/filters/reference/hold_peaks.html&gt;`_</span>
<span class="sd">    to view online example.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ascending</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>  <span class="c1"># Flip the axis of interest (-1)</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">updown</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="o">*</span><span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">B</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">updown</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">updown</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:],</span> <span class="n">B</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">out</span><span class="o">=</span><span class="n">updown</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">chnidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">updown</span><span class="p">)</span>
    <span class="n">chng</span> <span class="o">=</span> <span class="n">updown</span><span class="p">[</span><span class="n">chnidx</span><span class="p">]</span>
    <span class="p">(</span><span class="n">pkidx</span><span class="p">,)</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">chng</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">chng</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">chnidx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">pkidx</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="n">pkidx</span><span class="p">),</span> <span class="n">chnidx</span><span class="p">),)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">aux</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">aux</span><span class="p">[(</span><span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)),</span> <span class="n">pkidx</span><span class="p">),)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="n">pkidx</span><span class="p">])</span>
    <span class="n">aux</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ascending</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>  <span class="c1"># Flip it back</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="distance_transform_lin"><a class="viewcode-back" href="../../../modules/generated/generated/porespy.filters.distance_transform_lin.html#porespy.filters.distance_transform_lin">[docs]</a><span class="k">def</span> <span class="nf">distance_transform_lin</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Replaces each void voxel with the linear distance to the nearest solid</span>
<span class="sd">    voxel along the specified axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im : ndarray</span>
<span class="sd">        The image of the porous material with ``True`` values indicating</span>
<span class="sd">        the void phase (or phase of interest).</span>
<span class="sd">    axis : int</span>
<span class="sd">        The direction along which the distance should be measured, the</span>
<span class="sd">        default is 0 (i.e. along the x-direction).</span>
<span class="sd">    mode : str</span>
<span class="sd">        Controls how the distance is measured. Options are:</span>

<span class="sd">        &#39;forward&#39;</span>
<span class="sd">            Distances are measured in the increasing direction</span>
<span class="sd">            along the specified axis</span>
<span class="sd">        &#39;reverse&#39;</span>
<span class="sd">            Distances are measured in the reverse direction.</span>
<span class="sd">            &#39;backward&#39; is also accepted.</span>
<span class="sd">        &#39;both&#39;</span>
<span class="sd">            Distances are calculated in both directions (by</span>
<span class="sd">            recursively calling itself), then reporting the minimum value</span>
<span class="sd">            of the two results.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    image : ndarray</span>
<span class="sd">        A copy of ``im`` with each foreground voxel containing the</span>
<span class="sd">        distance to the nearest background along the specified axis.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    `Click here</span>
<span class="sd">    &lt;https://porespy.org/examples/filters/reference/distance_transform_lin.html&gt;`_</span>
<span class="sd">    to view online example.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_check_for_singleton_axes</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;backward&quot;</span><span class="p">,</span> <span class="s2">&quot;reverse&quot;</span><span class="p">]:</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">distance_transform_lin</span><span class="p">(</span><span class="n">im</span><span class="o">=</span><span class="n">im</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;forward&quot;</span><span class="p">)</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">im</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;both&quot;</span><span class="p">]:</span>
        <span class="n">im_f</span> <span class="o">=</span> <span class="n">distance_transform_lin</span><span class="p">(</span><span class="n">im</span><span class="o">=</span><span class="n">im</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;forward&quot;</span><span class="p">)</span>
        <span class="n">im_b</span> <span class="o">=</span> <span class="n">distance_transform_lin</span><span class="p">(</span><span class="n">im</span><span class="o">=</span><span class="n">im</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;backward&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">im_f</span><span class="p">,</span> <span class="n">im_b</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">im</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="p">(</span><span class="n">im</span> <span class="o">==</span> <span class="mi">0</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="o">.</span><span class="n">accumulate</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">im</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">pad_width</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">im</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="p">[[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]]</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">pad_width</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">im</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
            <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
            <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
        <span class="p">]</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">pad_width</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">im</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">e</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">f</span></div>


<div class="viewcode-block" id="find_disconnected_voxels"><a class="viewcode-back" href="../../../modules/generated/generated/porespy.filters.find_disconnected_voxels.html#porespy.filters.find_disconnected_voxels">[docs]</a><span class="k">def</span> <span class="nf">find_disconnected_voxels</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">conn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">surface</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Identifies all voxels that are not connected to the edge of the image.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im : ndarray</span>
<span class="sd">        A Boolean image, with ``True`` values indicating the phase for which</span>
<span class="sd">        disconnected voxels are sought.</span>
<span class="sd">    conn : int</span>
<span class="sd">        For 2D the options are 4 and 8 for square and diagonal neighbors,</span>
<span class="sd">        while for the 3D the options are 6 and 26, similarily for square</span>
<span class="sd">        and diagonal neighbors. The default is the maximum option.</span>
<span class="sd">    surface : bool</span>
<span class="sd">        If ``True`` any isolated regions touching the edge of the image are</span>
<span class="sd">        considered disconnected.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    image : ndarray</span>
<span class="sd">        An ndarray the same size as ``im``, with ``True`` values indicating</span>
<span class="sd">        voxels of the phase of interest (i.e. ``True`` values in the original</span>
<span class="sd">        image) that are not connected to the outer edges.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    fill_blind_pores, trim_floating_solid</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function is just a convenient wrapper around the ``clear_border``</span>
<span class="sd">    function of ``scikit-image``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    `Click here</span>
<span class="sd">    &lt;https://porespy.org/examples/filters/reference/find_disconnected_voxels.html&gt;`_</span>
<span class="sd">    to view online example.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_check_for_singleton_axes</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">im</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">conn</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">strel</span> <span class="o">=</span> <span class="n">disk</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">conn</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="mi">8</span><span class="p">]:</span>
            <span class="n">strel</span> <span class="o">=</span> <span class="n">square</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Received conn is not valid&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">im</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">conn</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
            <span class="n">strel</span> <span class="o">=</span> <span class="n">ball</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">conn</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="mi">26</span><span class="p">]:</span>
            <span class="n">strel</span> <span class="o">=</span> <span class="n">cube</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Received conn is not valid&quot;</span><span class="p">)</span>
    <span class="n">labels</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">spim</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="n">im</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">strel</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">surface</span><span class="p">:</span>
        <span class="n">holes</span> <span class="o">=</span> <span class="n">clear_border</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">labels</span><span class="o">.</span><span class="n">flatten</span><span class="p">())[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">counts</span> <span class="o">==</span> <span class="n">counts</span><span class="o">.</span><span class="n">max</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">holes</span> <span class="o">=</span> <span class="p">(</span><span class="n">labels</span> <span class="o">!=</span> <span class="n">keep</span><span class="p">)</span><span class="o">*</span><span class="n">im</span>
    <span class="k">return</span> <span class="n">holes</span></div>


<div class="viewcode-block" id="fill_blind_pores"><a class="viewcode-back" href="../../../modules/generated/generated/porespy.filters.fill_blind_pores.html#porespy.filters.fill_blind_pores">[docs]</a><span class="k">def</span> <span class="nf">fill_blind_pores</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">conn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">surface</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fills all blind pores that are isolated from the main void space.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im : ndarray</span>
<span class="sd">        The image of the porous material</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    im : ndarray</span>
<span class="sd">        A version of ``im`` but with all the disconnected pores removed.</span>
<span class="sd">    conn : int</span>
<span class="sd">        For 2D the options are 4 and 8 for square and diagonal neighbors,</span>
<span class="sd">        while for the 3D the options are 6 and 26, similarily for square</span>
<span class="sd">        and diagonal neighbors. The default is the maximum option.</span>
<span class="sd">    surface : bool</span>
<span class="sd">        If ``True``, any isolated pore regions that are connected to the</span>
<span class="sd">        sufaces of the image are but not connected to the main percolating</span>
<span class="sd">        path are also removed. When this is enabled, only the voxels</span>
<span class="sd">        belonging to the largest region are kept. This can be</span>
<span class="sd">        problematic if image contains non-intersecting tube-like structures,</span>
<span class="sd">        for instance, since only the largest tube will be preserved.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    find_disconnected_voxels</span>
<span class="sd">    trim_nonpercolating_paths</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    `Click here</span>
<span class="sd">    &lt;https://porespy.org/examples/filters/reference/fill_blind_pores.html&gt;`_</span>
<span class="sd">    to view online example.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
    <span class="n">holes</span> <span class="o">=</span> <span class="n">find_disconnected_voxels</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">conn</span><span class="o">=</span><span class="n">conn</span><span class="p">,</span> <span class="n">surface</span><span class="o">=</span><span class="n">surface</span><span class="p">)</span>
    <span class="n">im</span><span class="p">[</span><span class="n">holes</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="n">im</span></div>


<div class="viewcode-block" id="trim_floating_solid"><a class="viewcode-back" href="../../../modules/generated/generated/porespy.filters.trim_floating_solid.html#porespy.filters.trim_floating_solid">[docs]</a><span class="k">def</span> <span class="nf">trim_floating_solid</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">conn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">surface</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Removes all solid that that is not attached to main solid structure.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im : ndarray</span>
<span class="sd">        The image of the porous material</span>
<span class="sd">    conn : int</span>
<span class="sd">        For 2D the options are 4 and 8 for square and diagonal neighbors,</span>
<span class="sd">        while for the 3D the options are 6 and 26, similarily for square</span>
<span class="sd">        and diagonal neighbors. The default is the maximum option.</span>
<span class="sd">    surface : bool</span>
<span class="sd">        If ``True``, any isolated solid regions that are connected to the</span>
<span class="sd">        surfaces of the image but not the main body of the solid are also</span>
<span class="sd">        removed.  When this is enabled, only the voxels belonging to the</span>
<span class="sd">        largest region are kept. This can be problematic if the image</span>
<span class="sd">        contains non-intersecting tube-like structures, for instance,</span>
<span class="sd">        since only the largest tube will be preserved.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    image : ndarray</span>
<span class="sd">        A version of ``im`` but with all the disconnected solid removed.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    find_disconnected_voxels</span>
<span class="sd">    trim_nonpercolating_paths</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    `Click here</span>
<span class="sd">    &lt;https://porespy.org/examples/filters/reference/trim_floating_solid.html&gt;`_</span>
<span class="sd">    to view online example.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
    <span class="n">holes</span> <span class="o">=</span> <span class="n">find_disconnected_voxels</span><span class="p">(</span><span class="o">~</span><span class="n">im</span><span class="p">,</span> <span class="n">conn</span><span class="o">=</span><span class="n">conn</span><span class="p">,</span> <span class="n">surface</span><span class="o">=</span><span class="n">surface</span><span class="p">)</span>
    <span class="n">im</span><span class="p">[</span><span class="n">holes</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="n">im</span></div>


<div class="viewcode-block" id="trim_nonpercolating_paths"><a class="viewcode-back" href="../../../modules/generated/generated/porespy.filters.trim_nonpercolating_paths.html#porespy.filters.trim_nonpercolating_paths">[docs]</a><span class="k">def</span> <span class="nf">trim_nonpercolating_paths</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">inlets</span><span class="p">,</span> <span class="n">outlets</span><span class="p">,</span> <span class="n">strel</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove all nonpercolating paths between specified locations</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im : ndarray</span>
<span class="sd">        The image of the porous material with ```True`` values indicating the</span>
<span class="sd">        phase of interest</span>
<span class="sd">    inlets : ndarray</span>
<span class="sd">        A boolean mask indicating locations of inlets, such as produced by</span>
<span class="sd">        ``porespy.generators.faces``.</span>
<span class="sd">    outlets : ndarray</span>
<span class="sd">        A boolean mask indicating locations of outlets, such as produced by</span>
<span class="sd">        ``porespy.generators.faces``.</span>
<span class="sd">    strel : ndarray</span>
<span class="sd">        The structuring element to use when determining if regions are</span>
<span class="sd">        connected.  This is passed to ``scipiy.ndimage.label``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    image : ndarray</span>
<span class="sd">        A copy of ``im`` with all the nonpercolating paths removed</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function is essential when performing transport simulations on an</span>
<span class="sd">    image since regions that do not span between the desired inlet and</span>
<span class="sd">    outlet do not contribute to the transport.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    find_disconnected_voxels</span>
<span class="sd">    trim_floating_solid</span>
<span class="sd">    trim_blind_pores</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    `Click here</span>
<span class="sd">    &lt;https://porespy.org/examples/filters/reference/trim_nonpercolating_paths.html&gt;`_</span>
<span class="sd">    to view online example.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">spim</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">strel</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">IN</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span> <span class="o">*</span> <span class="n">inlets</span><span class="p">)</span>
    <span class="n">OUT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span> <span class="o">*</span> <span class="n">outlets</span><span class="p">)</span>
    <span class="n">hits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">IN</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">OUT</span><span class="p">))))</span>
    <span class="n">new_im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">hits</span><span class="p">[</span><span class="n">hits</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">new_im</span></div>


<div class="viewcode-block" id="trim_extrema"><a class="viewcode-back" href="../../../modules/generated/generated/porespy.filters.trim_extrema.html#porespy.filters.trim_extrema">[docs]</a><span class="k">def</span> <span class="nf">trim_extrema</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;maxima&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Trims local extrema in greyscale values by a specified amount.</span>

<span class="sd">    This essentially decapitates peaks and/or floods valleys.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im : ndarray</span>
<span class="sd">        The image whose extrema are to be removed</span>
<span class="sd">    h : float</span>
<span class="sd">        The height to remove from each peak or fill in each valley</span>
<span class="sd">    mode : string {&#39;maxima&#39; | &#39;minima&#39; | &#39;extrema&#39;}</span>
<span class="sd">        Specifies whether to remove maxima or minima or both</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    image : ndarray</span>
<span class="sd">        A copy of the input image with all the peaks and/or valleys</span>
<span class="sd">        removed.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    (1) This function is referred to as **imhmax** or **imhmin** in Matlab.</span>

<span class="sd">    (2) If the provided ``h`` is larger than ALL peaks in the array, then the</span>
<span class="sd">    baseline values of the array are changed as well.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    `Click here</span>
<span class="sd">    &lt;https://porespy.org/examples/filters/reference/trim_extrema.html&gt;`_</span>
<span class="sd">    to view online example.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
    <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;maxima&#39;</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">reconstruction</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">im</span> <span class="o">-</span> <span class="n">h</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;dilation&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;minima&#39;</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">reconstruction</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">im</span> <span class="o">+</span> <span class="n">h</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;erosion&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;extrema&#39;</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">reconstruction</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">im</span> <span class="o">-</span> <span class="n">h</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;dilation&#39;</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">reconstruction</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">result</span> <span class="o">+</span> <span class="n">h</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">result</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;erosion&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="flood"><a class="viewcode-back" href="../../../modules/generated/generated/porespy.filters.flood.html#porespy.filters.flood">[docs]</a><span class="k">def</span> <span class="nf">flood</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;max&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Floods/fills each region in an image with a single value based on the</span>
<span class="sd">    specific values in that region.</span>

<span class="sd">    This function calls the various functions in ``scipy.ndimage.measurements``</span>
<span class="sd">    but instead of returning a list of values, it fills each region with its</span>
<span class="sd">    value.  This is useful for visualization and statistics.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im : array_like</span>
<span class="sd">        An image with the numerical values of interest in each voxel,</span>
<span class="sd">        and 0&#39;s elsewhere.</span>
<span class="sd">    labels : array_like</span>
<span class="sd">        An array the same shape as ``im`` with each region labeled.</span>
<span class="sd">    mode : string</span>
<span class="sd">        Specifies how to determine the value to flood each region. Options</span>
<span class="sd">        taken from the ``scipy.ndimage.measurements`` functions:</span>

<span class="sd">            &#39;maximum&#39;</span>
<span class="sd">                Floods each region with the local max in that region. The</span>
<span class="sd">                keyword ``max`` is also accepted.</span>
<span class="sd">            &#39;minimum&#39;</span>
<span class="sd">                Floods each region the local minimum in that region. The</span>
<span class="sd">                keyword ``min`` is also accepted.</span>
<span class="sd">            &#39;median&#39;</span>
<span class="sd">                Floods each region the local median in that region</span>
<span class="sd">            &#39;mean&#39;</span>
<span class="sd">                Floods each region the local mean in that region</span>
<span class="sd">            &#39;size&#39;</span>
<span class="sd">                Floods each region with the size of that region.  This is</span>
<span class="sd">                actually accomplished with ``scipy.ndimage.sum`` by converting</span>
<span class="sd">                ``im`` to a boolean image (``im = im &gt; 0``).</span>
<span class="sd">            &#39;standard_deviation&#39;</span>
<span class="sd">                Floods each region with the value of the standard deviation</span>
<span class="sd">                of the voxels in ``im``.</span>
<span class="sd">            &#39;variance&#39;</span>
<span class="sd">                Floods each region with the value of the variance of the voxels</span>
<span class="sd">                in ``im``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    flooded : ndarray</span>
<span class="sd">        A copy of ``im`` with new values placed in each forground voxel</span>
<span class="sd">        based on the ``mode``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    prop_to_image, flood_func, region_size</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    `Click here</span>
<span class="sd">    &lt;https://porespy.org/examples/filters/reference/flood.html&gt;`_</span>
<span class="sd">    to view online example.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">im</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">mode</span> <span class="o">=</span> <span class="s2">&quot;sum&quot;</span> <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;size&quot;</span> <span class="k">else</span> <span class="n">mode</span>
    <span class="n">mode</span> <span class="o">=</span> <span class="s2">&quot;maximum&quot;</span> <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;max&quot;</span> <span class="k">else</span> <span class="n">mode</span>
    <span class="n">mode</span> <span class="o">=</span> <span class="s2">&quot;minimum&quot;</span> <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;min&quot;</span> <span class="k">else</span> <span class="n">mode</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">spim</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
    <span class="n">vals</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="n">im</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">flooded</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="n">labels</span><span class="p">]</span>
    <span class="n">flooded</span> <span class="o">=</span> <span class="n">flooded</span> <span class="o">*</span> <span class="n">mask</span>
    <span class="k">return</span> <span class="n">flooded</span></div>


<div class="viewcode-block" id="flood_func"><a class="viewcode-back" href="../../../modules/generated/generated/porespy.filters.flood_func.html#porespy.filters.flood_func">[docs]</a><span class="k">def</span> <span class="nf">flood_func</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Flood each isolated region in an image with a constant value calculated by</span>
<span class="sd">    the given function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im : ndarray</span>
<span class="sd">        An image with the numerical values of interest in each voxel,</span>
<span class="sd">        and 0&#39;s elsewhere.</span>
<span class="sd">    func : Numpy function handle</span>
<span class="sd">        The function to be applied to each region in the image.  Any Numpy</span>
<span class="sd">        function that returns a scalar value can be passed, such as ``amin``,</span>
<span class="sd">        ``amax``, ``sum``, ``mean``, ``median``, etc.</span>
<span class="sd">    labels : ndarray</span>
<span class="sd">        An array containing labels identifying each individual region to be</span>
<span class="sd">        flooded. If not provided then ``scipy.ndimage.label`` is applied to</span>
<span class="sd">        ``im &gt; 0``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    flooded : ndarray</span>
<span class="sd">        An image the same size as ``im`` with each isolated region flooded</span>
<span class="sd">        with a constant value based on the given ``func`` and the values</span>
<span class="sd">        in ``im``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    flood, region_size</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Many of the functions in ``scipy.ndimage`` can be applied to</span>
<span class="sd">    individual regions using the ``index`` argument.  This function extends</span>
<span class="sd">    that behavior to all numpy function, in the event you wanted to compute</span>
<span class="sd">    the cosine of the values in each region for some reason. This function</span>
<span class="sd">    also floods the original image instead of returning a list of values for</span>
<span class="sd">    each region.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    `Click here</span>
<span class="sd">    &lt;https://porespy.org/examples/filters/reference/flood_func.html&gt;`_</span>
<span class="sd">    to view online example.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">spim</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">im</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">slices</span> <span class="o">=</span> <span class="n">spim</span><span class="o">.</span><span class="n">find_objects</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
    <span class="n">flooded</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">slices</span><span class="p">):</span>
        <span class="n">sub_im</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">im</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">sub_im</span><span class="p">])</span>
        <span class="n">flooded</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sub_im</span><span class="o">*</span><span class="n">val</span>
    <span class="k">return</span> <span class="n">flooded</span></div>


<div class="viewcode-block" id="find_dt_artifacts"><a class="viewcode-back" href="../../../modules/generated/generated/porespy.filters.find_dt_artifacts.html#porespy.filters.find_dt_artifacts">[docs]</a><span class="k">def</span> <span class="nf">find_dt_artifacts</span><span class="p">(</span><span class="n">dt</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Label points in a distance transform that are closer to image boundary</span>
<span class="sd">    than solid</span>

<span class="sd">    These points could *potentially* be erroneously high since their</span>
<span class="sd">    distance values do not reflect the possibility that solid may have</span>
<span class="sd">    been present beyond the border of the image but was lost by trimming.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dt : ndarray</span>
<span class="sd">        The distance transform of the phase of interest.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    image : ndarray</span>
<span class="sd">        An ndarray the same shape as ``dt`` with numerical values</span>
<span class="sd">        indicating the maximum amount of error in each volxel, which is</span>
<span class="sd">        found by subtracting the distance to nearest edge of image from</span>
<span class="sd">        the distance transform value. In other words, this is the error</span>
<span class="sd">        that would be found if there were a solid voxel lurking just</span>
<span class="sd">        beyond the nearest edge of the image.  Obviously, voxels with a</span>
<span class="sd">        value of zero have no error.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    `Click here</span>
<span class="sd">    &lt;https://porespy.org/examples/filters/reference/find_dt_artifacts.html&gt;`_</span>
<span class="sd">    to view online example.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">dt</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
        <span class="n">dt_lin</span> <span class="o">=</span> <span class="n">distance_transform_lin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">),</span>
                                        <span class="n">axis</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">)</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">dt_lin</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">dt</span> <span class="o">-</span> <span class="n">temp</span><span class="p">,</span> <span class="n">a_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">a_max</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="region_size"><a class="viewcode-back" href="../../../modules/generated/generated/porespy.filters.region_size.html#porespy.filters.region_size">[docs]</a><span class="k">def</span> <span class="nf">region_size</span><span class="p">(</span><span class="n">im</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Replace each voxel with the size of the region to which it belongs</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im : ndarray</span>
<span class="sd">        Either a boolean image wtih ``True`` indicating the features of</span>
<span class="sd">        interest, in which case ``scipy.ndimage.label`` will be applied to</span>
<span class="sd">        find regions, or a greyscale image with integer values indicating</span>
<span class="sd">        regions.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    image : ndarray</span>
<span class="sd">        A copy of ``im`` with each voxel value indicating the size of the</span>
<span class="sd">        region to which it belongs.  This is particularly useful for</span>
<span class="sd">        finding chord sizes on the image produced by ``apply_chords``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    flood</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function provides the same result as ``flood`` with ``mode=&#39;size&#39;``,</span>
<span class="sd">    although does the computation in a different way.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    `Click here</span>
<span class="sd">    &lt;https://porespy.org/examples/filters/reference/region_size.html&gt;`_</span>
<span class="sd">    to view online example.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">im</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">spim</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">im</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
    <span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">counts</span><span class="p">[</span><span class="n">im</span><span class="p">]</span></div>


<div class="viewcode-block" id="apply_chords"><a class="viewcode-back" href="../../../modules/generated/generated/porespy.filters.apply_chords.html#porespy.filters.apply_chords">[docs]</a><span class="k">def</span> <span class="nf">apply_chords</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">spacing</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">trim_edges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adds chords to the void space in the specified direction.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im : ndarray</span>
<span class="sd">        An image of the porous material with void marked as ``True``.</span>
<span class="sd">    spacing : int</span>
<span class="sd">        Separation between chords.  The default is 1 voxel.  This can be</span>
<span class="sd">        decreased to 0, meaning that the chords all touch each other,</span>
<span class="sd">        which automatically sets to the ``label`` argument to ``True``.</span>
<span class="sd">    axis : int (default = 0)</span>
<span class="sd">        The axis along which the chords are drawn.</span>
<span class="sd">    trim_edges : bool (default = ``True``)</span>
<span class="sd">        Whether or not to remove chords that touch the edges of the image.</span>
<span class="sd">        These chords are artifically shortened, so skew the chord length</span>
<span class="sd">        distribution.</span>
<span class="sd">    label : bool (default is ``False``)</span>
<span class="sd">        If ``True`` the chords in the returned image are each given a</span>
<span class="sd">        unique label, such that all voxels lying on the same chord have</span>
<span class="sd">        the same value.  This is automatically set to ``True`` if spacing</span>
<span class="sd">        is 0, but is ``False`` otherwise.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    image : ndarray</span>
<span class="sd">        A copy of ``im`` with non-zero values indicating the chords.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    apply_chords_3D</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    `Click here</span>
<span class="sd">    &lt;https://porespy.org/examples/filters/reference/apply_chords.html&gt;`_</span>
<span class="sd">    to view online example.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_check_for_singleton_axes</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">spacing</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Spacing cannot be less than 0&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">spacing</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">label</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>  <span class="c1"># Will receive chords at end</span>
    <span class="n">slxyz</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">spacing</span> <span class="o">*</span> <span class="p">(</span><span class="n">axis</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
    <span class="n">slices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">slxyz</span><span class="p">[:</span> <span class="n">im</span><span class="o">.</span><span class="n">ndim</span><span class="p">])</span>
    <span class="n">s</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>  <span class="c1"># Straight-line structuring element</span>
    <span class="k">if</span> <span class="n">im</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1"># Make structuring element 3D if necessary</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_3d</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">pad_width</span><span class="o">=</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
                   <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">im</span> <span class="o">=</span> <span class="n">im</span><span class="p">[</span><span class="n">slices</span><span class="p">]</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
    <span class="n">chords</span> <span class="o">=</span> <span class="n">spim</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">s</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">trim_edges</span><span class="p">:</span>  <span class="c1"># Label on border chords will be set to 0</span>
        <span class="n">chords</span> <span class="o">=</span> <span class="n">clear_border</span><span class="p">(</span><span class="n">chords</span><span class="p">)</span>
    <span class="n">result</span><span class="p">[</span><span class="n">slices</span><span class="p">]</span> <span class="o">=</span> <span class="n">chords</span>  <span class="c1"># Place chords into empty image created at top</span>
    <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>  <span class="c1"># Remove label if not requested</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="apply_chords_3D"><a class="viewcode-back" href="../../../modules/generated/generated/porespy.filters.apply_chords_3D.html#porespy.filters.apply_chords_3D">[docs]</a><span class="k">def</span> <span class="nf">apply_chords_3D</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">spacing</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">trim_edges</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adds chords to the void space in all three principle directions.</span>

<span class="sd">    Chords in the X, Y and Z directions are labelled 1, 2 and 3 resepctively.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im : ndarray</span>
<span class="sd">        A 3D image of the porous material with void space marked as True.</span>
<span class="sd">    spacing : int (default = 0)</span>
<span class="sd">        Chords are automatically separed by 1 voxel on all sides, and this</span>
<span class="sd">        argument increases the separation.</span>
<span class="sd">    trim_edges : bool (default is ``True``)</span>
<span class="sd">        Whether or not to remove chords that touch the edges of the image.</span>
<span class="sd">        These chords are artifically shortened, so skew the chord length</span>
<span class="sd">        distribution</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    image : ndarray</span>
<span class="sd">        A copy of ``im`` with values of 1 indicating x-direction chords,</span>
<span class="sd">        2 indicating y-direction chords, and 3 indicating z-direction</span>
<span class="sd">        chords.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The chords are separated by a spacing of at least 1 voxel so that</span>
<span class="sd">    tools that search for connected components, such as</span>
<span class="sd">    ``scipy.ndimage.label`` can detect individual chords.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    apply_chords</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    `Click here</span>
<span class="sd">    &lt;https://porespy.org/examples/filters/reference/apply_chords_3D.html&gt;`_</span>
<span class="sd">    to view online example.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_check_for_singleton_axes</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">im</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Must be a 3D image to use this function&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">spacing</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Spacing cannot be less than 0&quot;</span><span class="p">)</span>
    <span class="n">ch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">ch</span><span class="p">[:,</span> <span class="p">::</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">spacing</span><span class="p">,</span> <span class="p">::</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">spacing</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>   <span class="c1"># X-direction</span>
    <span class="n">ch</span><span class="p">[::</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">spacing</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">::</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">spacing</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>   <span class="c1"># Y-direction</span>
    <span class="n">ch</span><span class="p">[</span><span class="mi">2</span><span class="p">::</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">spacing</span><span class="p">,</span> <span class="mi">2</span><span class="p">::</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">spacing</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">3</span>   <span class="c1"># Z-direction</span>
    <span class="n">chords</span> <span class="o">=</span> <span class="n">ch</span> <span class="o">*</span> <span class="n">im</span>
    <span class="k">if</span> <span class="n">trim_edges</span><span class="p">:</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">clear_border</span><span class="p">(</span><span class="n">spim</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">chords</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">chords</span> <span class="o">=</span> <span class="n">temp</span> <span class="o">*</span> <span class="n">chords</span>
    <span class="k">return</span> <span class="n">chords</span></div>


<div class="viewcode-block" id="local_thickness"><a class="viewcode-back" href="../../../modules/generated/generated/porespy.filters.local_thickness.html#porespy.filters.local_thickness">[docs]</a><span class="k">def</span> <span class="nf">local_thickness</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">sizes</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;hybrid&quot;</span><span class="p">,</span> <span class="n">divs</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For each voxel, this function calculates the radius of the largest</span>
<span class="sd">    sphere that both engulfs the voxel and fits entirely within the</span>
<span class="sd">    foreground.</span>

<span class="sd">    This is not the same as a simple distance transform, which finds the</span>
<span class="sd">    largest sphere that could be *centered* on each voxel.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im : ndarray</span>
<span class="sd">        A binary image with the phase of interest set to True</span>
<span class="sd">    sizes : array_like or scalar</span>
<span class="sd">        The sizes to invade.  If a list of values of provided they are</span>
<span class="sd">        used directly. If a scalar is provided then that number of points</span>
<span class="sd">        spanning the min and max of the distance transform are used.</span>
<span class="sd">    mode : str</span>
<span class="sd">        Controls with method is used to compute the result. Options are:</span>

<span class="sd">        &#39;hybrid&#39;</span>
<span class="sd">            (default) Performs a distance transform of the void</span>
<span class="sd">            space, thresholds to find voxels larger than ``sizes[i]``, trims</span>
<span class="sd">            the resulting mask if ``access_limitations`` is ``True``, then</span>
<span class="sd">            dilates it using the efficient fft-method to obtain the</span>
<span class="sd">            non-wetting fluid configuration.</span>
<span class="sd">        &#39;dt&#39;</span>
<span class="sd">            Same as &#39;hybrid&#39;, except uses a second distance transform,</span>
<span class="sd">            relative to the thresholded mask, to find the invading fluid</span>
<span class="sd">            configuration. The choice of &#39;dt&#39; or &#39;hybrid&#39; depends on speed,</span>
<span class="sd">            which is system and installation specific.</span>
<span class="sd">        &#39;mio&#39;</span>
<span class="sd">            Using a single morphological image opening step to obtain</span>
<span class="sd">            the invading fluid confirguration directly, *then* trims if</span>
<span class="sd">            ``access_limitations`` is ``True``. This method is not ideal and</span>
<span class="sd">            is included for comparison purposes.</span>

<span class="sd">    divs : int or array_like</span>
<span class="sd">        The number of times to divide the image for parallel processing.  If ``1``</span>
<span class="sd">        then parallel processing does not occur.  ``2`` is equivalent to</span>
<span class="sd">        ``[2, 2, 2]`` for a 3D image.  The number of cores used is specified in</span>
<span class="sd">        ``porespy.settings.ncores`` and defaults to all cores.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    image : ndarray</span>
<span class="sd">        A copy of ``im`` with the pore size values in each voxel.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    porosimetry</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The term *foreground* is used since this function can be applied to</span>
<span class="sd">    both pore space or the solid, whichever is set to ``True``.</span>

<span class="sd">    This function is identical to ``porosimetry`` with ``access_limited``</span>
<span class="sd">    set to ``False``.</span>

<span class="sd">    The way local thickness is found in PoreSpy differs from the</span>
<span class="sd">    traditional method (i.e. used in ImageJ</span>
<span class="sd">    `&lt;https://imagej.net/Local_Thickness&gt;`_). Our approach is probably</span>
<span class="sd">    slower, but it allows for the same code to be used for</span>
<span class="sd">    ``local_thickness`` and ``porosimetry``, since we can &#39;trim&#39; invaded</span>
<span class="sd">    regions that are not connected to the inlets in the ``porosimetry``</span>
<span class="sd">    function. This is not needed in ``local_thickness`` however.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    `Click here</span>
<span class="sd">    &lt;https://porespy.org/examples/filters/reference/local_thickness.html&gt;`_</span>
<span class="sd">    to view online example.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">im_new</span> <span class="o">=</span> <span class="n">porosimetry</span><span class="p">(</span><span class="n">im</span><span class="o">=</span><span class="n">im</span><span class="p">,</span> <span class="n">sizes</span><span class="o">=</span><span class="n">sizes</span><span class="p">,</span> <span class="n">access_limited</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                         <span class="n">divs</span><span class="o">=</span><span class="n">divs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">im_new</span></div>


<div class="viewcode-block" id="porosimetry"><a class="viewcode-back" href="../../../modules/generated/generated/porespy.filters.porosimetry.html#porespy.filters.porosimetry">[docs]</a><span class="k">def</span> <span class="nf">porosimetry</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">sizes</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">inlets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">access_limited</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;hybrid&#39;</span><span class="p">,</span>
                <span class="n">divs</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs a porosimetry simulution on an image.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im : ndarray</span>
<span class="sd">        An ND image of the porous material containing ``True`` values in the</span>
<span class="sd">        pore space.</span>
<span class="sd">    sizes : array_like or scalar</span>
<span class="sd">        The sizes to invade.  If a list of values of provided they are</span>
<span class="sd">        used directly.  If a scalar is provided then that number of points</span>
<span class="sd">        spanning the min and max of the distance transform are used.</span>
<span class="sd">    inlets : ndarray, boolean</span>
<span class="sd">        A boolean mask with ``True`` values indicating where the invasion</span>
<span class="sd">        enters the image.  By default all faces are considered inlets,</span>
<span class="sd">        akin to a mercury porosimetry experiment.  Users can also apply</span>
<span class="sd">        solid boundaries to their image externally before passing it in,</span>
<span class="sd">        allowing for complex inlets like circular openings, etc.</span>
<span class="sd">        This argument is only used if ``access_limited`` is ``True``.</span>
<span class="sd">    access_limited : bool</span>
<span class="sd">        This flag indicates if the intrusion should only occur from the</span>
<span class="sd">        surfaces (``access_limited`` is ``True``, which is the default),</span>
<span class="sd">        or if the invading phase should be allowed to appear in the core</span>
<span class="sd">        of the image.  The former simulates experimental tools like</span>
<span class="sd">        mercury intrusion porosimetry, while the latter is useful for</span>
<span class="sd">        comparison to gauge the extent of shielding effects in the sample.</span>
<span class="sd">    mode : str</span>
<span class="sd">        Controls with method is used to compute the result. Options are:</span>

<span class="sd">        &#39;hybrid&#39;</span>
<span class="sd">            (default) Performs a distance tranform of the void</span>
<span class="sd">            space, thresholds to find voxels larger than ``sizes[i]``,</span>
<span class="sd">            trims the resulting mask if ``access_limitations`` is ``True``,</span>
<span class="sd">            then dilates it using the efficient fft-method to obtain the</span>
<span class="sd">            non-wetting fluid configuration.</span>
<span class="sd">        &#39;dt&#39;</span>
<span class="sd">            Same as &#39;hybrid&#39;, except uses a second distance</span>
<span class="sd">            transform, relative to the thresholded mask, to find the</span>
<span class="sd">            invading fluid configuration. The choice of &#39;dt&#39; or &#39;hybrid&#39;</span>
<span class="sd">            depends on speed, which is system and installation specific.</span>
<span class="sd">        &#39;mio&#39;</span>
<span class="sd">            Uses bindary erosion followed by dilation to obtain the invading</span>
<span class="sd">            fluid confirguration directly. If ``access_limitations`` is</span>
<span class="sd">            ``True`` then disconnected blobs are trimmmed before the dilation.</span>
<span class="sd">            This is the only method that can be parallelized by chunking (see</span>
<span class="sd">            ``divs`` and ``cores``).</span>

<span class="sd">    divs : int or array_like</span>
<span class="sd">        The number of times to divide the image for parallel processing.  If ``1``</span>
<span class="sd">        then parallel processing does not occur.  ``2`` is equivalent to</span>
<span class="sd">        ``[2, 2, 2]`` for a 3D image.  The number of cores used is specified in</span>
<span class="sd">        ``porespy.settings.ncores`` and defaults to all cores.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    image : ndarray</span>
<span class="sd">        A copy of ``im`` with voxel values indicating the sphere radius at</span>
<span class="sd">        which it becomes accessible from the inlets.  This image can be</span>
<span class="sd">        used to find invading fluid configurations as a function of</span>
<span class="sd">        applied capillary pressure by applying a boolean comparison:</span>
<span class="sd">        ``inv_phase = im &gt; r`` where ``r`` is the radius (in voxels) of</span>
<span class="sd">        the invading sphere.  Of course, ``r`` can be converted to</span>
<span class="sd">        capillary pressure using a preferred model.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    There are many ways to perform this filter, and PoreSpy offers 3,</span>
<span class="sd">    which users can choose between via the ``mode`` argument. These</span>
<span class="sd">    methods all work in a similar way by finding which foreground voxels</span>
<span class="sd">    can accomodate a sphere of a given radius, then repeating for smaller</span>
<span class="sd">    radii.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    local_thickness</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    `Click here</span>
<span class="sd">    &lt;https://porespy.org/examples/filters/reference/porosimetry.html&gt;`_</span>
<span class="sd">    to view online example.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">porespy.filters</span> <span class="kn">import</span> <span class="n">fftmorphology</span>
    <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">edt</span><span class="p">(</span><span class="n">im</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">inlets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">inlets</span> <span class="o">=</span> <span class="n">get_border</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;faces&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sizes</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">dt</span><span class="p">)),</span> <span class="n">stop</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">sizes</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sizes</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">im</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">strel</span> <span class="o">=</span> <span class="n">ps_disk</span>
        <span class="n">strel_2</span> <span class="o">=</span> <span class="n">disk</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">strel</span> <span class="o">=</span> <span class="n">ps_ball</span>
        <span class="n">strel_2</span> <span class="o">=</span> <span class="n">ball</span>

    <span class="n">parallel</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">divs</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">divs</span> <span class="o">=</span> <span class="p">[</span><span class="n">divs</span><span class="p">]</span><span class="o">*</span><span class="n">im</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">divs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Performing </span><span class="si">{</span><span class="n">insp</span><span class="o">.</span><span class="n">currentframe</span><span class="p">()</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span><span class="si">}</span><span class="s1"> in parallel&#39;</span><span class="p">)</span>
        <span class="n">parallel</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;mio&quot;</span><span class="p">:</span>
        <span class="n">pw</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>
        <span class="n">impad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;symmetric&quot;</span><span class="p">,</span> <span class="n">pad_width</span><span class="o">=</span><span class="n">pw</span><span class="p">)</span>
        <span class="n">inlets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">inlets</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;symmetric&quot;</span><span class="p">,</span> <span class="n">pad_width</span><span class="o">=</span><span class="n">pw</span><span class="p">)</span>
        <span class="c1"># sizes = np.unique(np.around(sizes, decimals=0).astype(int))[-1::-1]</span>
        <span class="n">imresults</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">impad</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">sizes</span><span class="p">,</span> <span class="o">**</span><span class="n">settings</span><span class="o">.</span><span class="n">tqdm</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">parallel</span><span class="p">:</span>
                <span class="n">imtemp</span> <span class="o">=</span> <span class="n">chunked_func</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">fftmorphology</span><span class="p">,</span>
                                      <span class="n">im</span><span class="o">=</span><span class="n">impad</span><span class="p">,</span> <span class="n">strel</span><span class="o">=</span><span class="n">strel</span><span class="p">(</span><span class="n">r</span><span class="p">),</span>
                                      <span class="n">overlap</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;erosion&#39;</span><span class="p">,</span>
                                      <span class="n">cores</span><span class="o">=</span><span class="n">settings</span><span class="o">.</span><span class="n">ncores</span><span class="p">,</span> <span class="n">divs</span><span class="o">=</span><span class="n">divs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">imtemp</span> <span class="o">=</span> <span class="n">fftmorphology</span><span class="p">(</span><span class="n">im</span><span class="o">=</span><span class="n">impad</span><span class="p">,</span> <span class="n">strel</span><span class="o">=</span><span class="n">strel</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;erosion&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">access_limited</span><span class="p">:</span>
                <span class="n">imtemp</span> <span class="o">=</span> <span class="n">trim_disconnected_blobs</span><span class="p">(</span><span class="n">imtemp</span><span class="p">,</span> <span class="n">inlets</span><span class="p">,</span>
                                                 <span class="n">strel</span><span class="o">=</span><span class="n">strel_2</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">parallel</span><span class="p">:</span>
                <span class="n">imtemp</span> <span class="o">=</span> <span class="n">chunked_func</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">fftmorphology</span><span class="p">,</span>
                                      <span class="n">im</span><span class="o">=</span><span class="n">imtemp</span><span class="p">,</span> <span class="n">strel</span><span class="o">=</span><span class="n">strel</span><span class="p">(</span><span class="n">r</span><span class="p">),</span>
                                      <span class="n">overlap</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;dilation&#39;</span><span class="p">,</span>
                                      <span class="n">cores</span><span class="o">=</span><span class="n">settings</span><span class="o">.</span><span class="n">ncores</span><span class="p">,</span> <span class="n">divs</span><span class="o">=</span><span class="n">divs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">imtemp</span> <span class="o">=</span> <span class="n">fftmorphology</span><span class="p">(</span><span class="n">im</span><span class="o">=</span><span class="n">imtemp</span><span class="p">,</span> <span class="n">strel</span><span class="o">=</span><span class="n">strel</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;dilation&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">imtemp</span><span class="p">):</span>
                <span class="n">imresults</span><span class="p">[(</span><span class="n">imresults</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">imtemp</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
        <span class="n">imresults</span> <span class="o">=</span> <span class="n">extract_subsection</span><span class="p">(</span><span class="n">imresults</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;dt&quot;</span><span class="p">:</span>
        <span class="n">imresults</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">im</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">sizes</span><span class="p">,</span> <span class="o">**</span><span class="n">settings</span><span class="o">.</span><span class="n">tqdm</span><span class="p">):</span>
            <span class="n">imtemp</span> <span class="o">=</span> <span class="n">dt</span> <span class="o">&gt;=</span> <span class="n">r</span>
            <span class="k">if</span> <span class="n">access_limited</span><span class="p">:</span>
                <span class="n">imtemp</span> <span class="o">=</span> <span class="n">trim_disconnected_blobs</span><span class="p">(</span><span class="n">imtemp</span><span class="p">,</span> <span class="n">inlets</span><span class="p">,</span>
                                                 <span class="n">strel</span><span class="o">=</span><span class="n">strel_2</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">imtemp</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">parallel</span><span class="p">:</span>
                    <span class="n">imtemp</span> <span class="o">=</span> <span class="n">chunked_func</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">edt</span><span class="p">,</span>
                                          <span class="n">data</span><span class="o">=~</span><span class="n">imtemp</span><span class="p">,</span> <span class="n">im_arg</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">,</span>
                                          <span class="n">overlap</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                          <span class="n">cores</span><span class="o">=</span><span class="n">settings</span><span class="o">.</span><span class="n">ncores</span><span class="p">,</span> <span class="n">divs</span><span class="o">=</span><span class="n">divs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">r</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">imtemp</span> <span class="o">=</span> <span class="n">edt</span><span class="p">(</span><span class="o">~</span><span class="n">imtemp</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">r</span>
                <span class="n">imresults</span><span class="p">[(</span><span class="n">imresults</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">imtemp</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;hybrid&quot;</span><span class="p">:</span>
        <span class="n">imresults</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">im</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">sizes</span><span class="p">,</span> <span class="o">**</span><span class="n">settings</span><span class="o">.</span><span class="n">tqdm</span><span class="p">):</span>
            <span class="n">imtemp</span> <span class="o">=</span> <span class="n">dt</span> <span class="o">&gt;=</span> <span class="n">r</span>
            <span class="k">if</span> <span class="n">access_limited</span><span class="p">:</span>
                <span class="n">imtemp</span> <span class="o">=</span> <span class="n">trim_disconnected_blobs</span><span class="p">(</span><span class="n">imtemp</span><span class="p">,</span> <span class="n">inlets</span><span class="p">,</span>
                                                 <span class="n">strel</span><span class="o">=</span><span class="n">strel_2</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">imtemp</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">parallel</span><span class="p">:</span>
                    <span class="n">imtemp</span> <span class="o">=</span> <span class="n">chunked_func</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">fftmorphology</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;dilation&#39;</span><span class="p">,</span>
                                          <span class="n">im</span><span class="o">=</span><span class="n">imtemp</span><span class="p">,</span> <span class="n">strel</span><span class="o">=</span><span class="n">strel</span><span class="p">(</span><span class="n">r</span><span class="p">),</span>
                                          <span class="n">overlap</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                          <span class="n">cores</span><span class="o">=</span><span class="n">settings</span><span class="o">.</span><span class="n">ncores</span><span class="p">,</span> <span class="n">divs</span><span class="o">=</span><span class="n">divs</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">imtemp</span> <span class="o">=</span> <span class="n">fftmorphology</span><span class="p">(</span><span class="n">imtemp</span><span class="p">,</span> <span class="n">strel</span><span class="p">(</span><span class="n">r</span><span class="p">),</span>
                                           <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;dilation&quot;</span><span class="p">)</span>
                <span class="n">imresults</span><span class="p">[(</span><span class="n">imresults</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">imtemp</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unrecognized mode &quot;</span> <span class="o">+</span> <span class="n">mode</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">imresults</span></div>


<div class="viewcode-block" id="trim_disconnected_blobs"><a class="viewcode-back" href="../../../modules/generated/generated/porespy.filters.trim_disconnected_blobs.html#porespy.filters.trim_disconnected_blobs">[docs]</a><span class="k">def</span> <span class="nf">trim_disconnected_blobs</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">inlets</span><span class="p">,</span> <span class="n">strel</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Removes foreground voxels not connected to specified inlets.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im : ndarray</span>
<span class="sd">        The image containing the blobs to be trimmed</span>
<span class="sd">    inlets : ndarray or tuple of indices</span>
<span class="sd">        The locations of the inlets.  Can either be a boolean mask the</span>
<span class="sd">        same shape as ``im``, or a tuple of indices such as that returned</span>
<span class="sd">        by the ``where`` function.  Any voxels *not* connected directly to</span>
<span class="sd">        the inlets will be trimmed.</span>
<span class="sd">    strel : array-like</span>
<span class="sd">        The neighborhood over which connectivity should be checked. It</span>
<span class="sd">        must be symmetric and the same dimensionality as the image. It is</span>
<span class="sd">        passed directly to the ``scipy.ndimage.label`` function as the</span>
<span class="sd">        ``structure`` argument so refer to that docstring for additional</span>
<span class="sd">        info.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    image : ndarray</span>
<span class="sd">        An array of the same shape as ``im``, but with all foreground</span>
<span class="sd">        voxels not connected to the ``inlets`` removed.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    find_disconnected_voxels, find_nonpercolating_paths</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    `Click here</span>
<span class="sd">    &lt;https://porespy.org/examples/filters/reference/trim_disconnected_blobs.html&gt;`_</span>
<span class="sd">    to view online example.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">inlets</span><span class="p">)</span> <span class="o">==</span> <span class="nb">tuple</span><span class="p">:</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">inlets</span><span class="p">)</span>
        <span class="n">inlets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">inlets</span><span class="p">[</span><span class="n">temp</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">inlets</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">inlets</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">inlets</span> <span class="o">=</span> <span class="n">inlets</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;inlets not valid, refer to docstring for info&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">strel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">im</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">strel</span> <span class="o">=</span> <span class="n">cube</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">strel</span> <span class="o">=</span> <span class="n">square</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">spim</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">inlets</span> <span class="o">+</span> <span class="p">(</span><span class="n">im</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">),</span> <span class="n">structure</span><span class="o">=</span><span class="n">strel</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">inlets</span><span class="p">])</span>
    <span class="n">keep</span> <span class="o">=</span> <span class="n">keep</span><span class="p">[</span><span class="n">keep</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">im2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">keep</span><span class="p">)</span>
    <span class="n">im2</span> <span class="o">=</span> <span class="n">im2</span> <span class="o">*</span> <span class="n">im</span>
    <span class="k">return</span> <span class="n">im2</span></div>


<span class="k">def</span> <span class="nf">_get_axial_shifts</span><span class="p">(</span><span class="n">ndim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">include_diagonals</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function to generate the axial shifts that will be performed on</span>
<span class="sd">    the image to identify bordering pixels/voxels</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">include_diagonals</span><span class="p">:</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="n">square</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="n">diamond</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">neighbors</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">y</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">include_diagonals</span><span class="p">:</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="n">cube</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="n">octahedron</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">neighbors</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">y</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">z</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>


<span class="k">def</span> <span class="nf">_make_stack</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">include_diagonals</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a stack of images with one extra dimension to the input image</span>
<span class="sd">    with length equal to the number of borders to search + 1.</span>

<span class="sd">    Image is rolled along the axial shifts so that the border pixel is</span>
<span class="sd">    overlapping the original pixel. First image in stack is the original.</span>
<span class="sd">    Stacking makes direct vectorized array comparisons possible.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">im</span><span class="p">))</span>
    <span class="n">axial_shift</span> <span class="o">=</span> <span class="n">_get_axial_shifts</span><span class="p">(</span><span class="n">ndim</span><span class="p">,</span> <span class="n">include_diagonals</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">im</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">im</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">axial_shift</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">im</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">axial_shift</span><span class="p">)):</span>
            <span class="n">ax0</span><span class="p">,</span> <span class="n">ax1</span> <span class="o">=</span> <span class="n">axial_shift</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">ax0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">ax1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>
        <span class="k">return</span> <span class="n">stack</span>
    <span class="k">elif</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">im</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">im</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">im</span><span class="p">)[</span><span class="mi">2</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">axial_shift</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">im</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">axial_shift</span><span class="p">)):</span>
            <span class="n">ax0</span><span class="p">,</span> <span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span> <span class="o">=</span> <span class="n">axial_shift</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">ax0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">ax1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">ax2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>
        <span class="k">return</span> <span class="n">stack</span>


<div class="viewcode-block" id="nphase_border"><a class="viewcode-back" href="../../../modules/generated/generated/porespy.filters.nphase_border.html#porespy.filters.nphase_border">[docs]</a><span class="k">def</span> <span class="nf">nphase_border</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">include_diagonals</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Identifies the voxels in regions that border *N* other regions.</span>

<span class="sd">    Useful for finding triple-phase boundaries.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im : ndarray</span>
<span class="sd">        An ND image of the porous material containing discrete values in</span>
<span class="sd">        the pore space identifying different regions. e.g. the result of a</span>
<span class="sd">        snow-partition</span>
<span class="sd">    include_diagonals : bool</span>
<span class="sd">        When identifying bordering pixels (2D) and voxels (3D) include</span>
<span class="sd">        those shifted along more than one axis</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    image : ndarray</span>
<span class="sd">        A copy of ``im`` with voxel values equal to the number of uniquely</span>
<span class="sd">        different bordering values</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    `Click here</span>
<span class="sd">    &lt;https://porespy.org/examples/filters/reference/nphase_border.html&gt;`_</span>
<span class="sd">    to view online example.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_check_for_singleton_axes</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
    <span class="c1"># Get dimension of image</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">im</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">ndim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Function only works for 2d and 3d images&quot;</span><span class="p">)</span>
    <span class="c1"># Pad image to handle edges</span>
    <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">pad_width</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;edge&quot;</span><span class="p">)</span>
    <span class="c1"># Stack rolled images for each neighbor to be inspected</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="n">_make_stack</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">include_diagonals</span><span class="p">)</span>
    <span class="c1"># Sort the stack along the last axis</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
    <span class="c1"># Run through stack recording when neighbor id changes</span>
    <span class="c1"># Number of changes is number of unique bordering regions</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">stack</span><span class="p">)[</span><span class="n">ndim</span><span class="p">])[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">!=</span> <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">!=</span> <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="n">mask</span>
    <span class="c1"># Un-pad</span>
    <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>


<div class="viewcode-block" id="prune_branches"><a class="viewcode-back" href="../../../modules/generated/generated/porespy.filters.prune_branches.html#porespy.filters.prune_branches">[docs]</a><span class="k">def</span> <span class="nf">prune_branches</span><span class="p">(</span><span class="n">skel</span><span class="p">,</span> <span class="n">branch_points</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove all dangling ends or tails of a skeleton</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    skel : ndarray</span>
<span class="sd">        A image of a full or partial skeleton from which the tails should</span>
<span class="sd">        be trimmed.</span>
<span class="sd">    branch_points : ndarray, optional</span>
<span class="sd">        An image the same size ``skel`` with ``True`` values indicating the</span>
<span class="sd">        branch points of the skeleton.  If this is not provided it is</span>
<span class="sd">        calculated automatically.</span>
<span class="sd">    iterations : int</span>
<span class="sd">        The number of times to recursively repeat the process.  The default is</span>
<span class="sd">        1.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array</span>
<span class="sd">        An ndarray containing the skeleton with tails removed.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    `Click here</span>
<span class="sd">    &lt;https://porespy.org/examples/filters/reference/prune_branches.html&gt;`_</span>
<span class="sd">    to view online example.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">skel</span> <span class="o">=</span> <span class="n">skel</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">skel</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">square</span> <span class="k">as</span> <span class="n">cube</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">cube</span>
    <span class="c1"># Create empty image to house results</span>
    <span class="n">im_result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">skel</span><span class="p">)</span>
    <span class="c1"># If branch points are not supplied, attempt to find them</span>
    <span class="k">if</span> <span class="n">branch_points</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">branch_points</span> <span class="o">=</span> <span class="n">spim</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">skel</span> <span class="o">*</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">cube</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">3</span>
        <span class="n">branch_points</span> <span class="o">=</span> <span class="n">branch_points</span> <span class="o">*</span> <span class="n">skel</span>
    <span class="c1"># Store original branch points before dilating</span>
    <span class="n">pts_orig</span> <span class="o">=</span> <span class="n">branch_points</span>
    <span class="c1"># Find arcs of skeleton by deleting branch points</span>
    <span class="n">arcs</span> <span class="o">=</span> <span class="n">skel</span> <span class="o">*</span> <span class="p">(</span><span class="o">~</span><span class="n">branch_points</span><span class="p">)</span>
    <span class="c1"># Label arcs</span>
    <span class="n">arc_labels</span> <span class="o">=</span> <span class="n">spim</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">arcs</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">cube</span><span class="p">(</span><span class="mi">3</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># Dilate branch points so they overlap with the arcs</span>
    <span class="n">branch_points</span> <span class="o">=</span> <span class="n">spim</span><span class="o">.</span><span class="n">binary_dilation</span><span class="p">(</span><span class="n">branch_points</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">cube</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">pts_labels</span> <span class="o">=</span> <span class="n">spim</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">branch_points</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">cube</span><span class="p">(</span><span class="mi">3</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># Now scan through each arc to see if it&#39;s connected to two branch points</span>
    <span class="n">slices</span> <span class="o">=</span> <span class="n">spim</span><span class="o">.</span><span class="n">find_objects</span><span class="p">(</span><span class="n">arc_labels</span><span class="p">)</span>
    <span class="n">label_num</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">slices</span><span class="p">:</span>
        <span class="n">label_num</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># Find branch point labels the overlap current arc</span>
        <span class="n">hits</span> <span class="o">=</span> <span class="n">pts_labels</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">arc_labels</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">==</span> <span class="n">label_num</span><span class="p">)</span>
        <span class="c1"># If image contains 2 branch points, then it&#39;s not a tail.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">hits</span><span class="p">))</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">im_result</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">+=</span> <span class="n">arc_labels</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">==</span> <span class="n">label_num</span>
    <span class="c1"># Add missing branch points back to arc image to make complete skeleton</span>
    <span class="n">im_result</span> <span class="o">+=</span> <span class="n">skel</span> <span class="o">*</span> <span class="n">pts_orig</span>
    <span class="k">if</span> <span class="n">iterations</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">iterations</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">im_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">im_result</span><span class="p">)</span>
        <span class="n">im_result</span> <span class="o">=</span> <span class="n">prune_branches</span><span class="p">(</span><span class="n">skel</span><span class="o">=</span><span class="n">im_result</span><span class="p">,</span>
                                   <span class="n">branch_points</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                   <span class="n">iterations</span><span class="o">=</span><span class="n">iterations</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">im_temp</span> <span class="o">==</span> <span class="n">im_result</span><span class="p">):</span>
            <span class="n">iterations</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">im_result</span></div>


<div class="viewcode-block" id="chunked_func"><a class="viewcode-back" href="../../../modules/generated/generated/porespy.filters.chunked_func.html#porespy.filters.chunked_func">[docs]</a><span class="k">def</span> <span class="nf">chunked_func</span><span class="p">(</span><span class="n">func</span><span class="p">,</span>
                 <span class="n">overlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">divs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                 <span class="n">cores</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">im_arg</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">,</span> <span class="s2">&quot;image&quot;</span><span class="p">,</span> <span class="s2">&quot;im&quot;</span><span class="p">],</span>
                 <span class="n">strel_arg</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;strel&quot;</span><span class="p">,</span> <span class="s2">&quot;structure&quot;</span><span class="p">,</span> <span class="s2">&quot;footprint&quot;</span><span class="p">],</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs the specfied operation &quot;chunk-wise&quot; in parallel using ``dask``.</span>

<span class="sd">    This can be used to save memory by doing one chunk at a time</span>
<span class="sd">    (``cores=1``) or to increase computation speed by spreading the work</span>
<span class="sd">    across multiple cores (e.g. ``cores=8``)</span>

<span class="sd">    This function can be used with any operation that applies a</span>
<span class="sd">    structuring element of some sort, since this implies that the</span>
<span class="sd">    operation is local and can be chunked.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    func : function handle</span>
<span class="sd">        The function which should be applied to each chunk, such as</span>
<span class="sd">        ``spipy.ndimage.binary_dilation``.</span>
<span class="sd">    overlap : scalar or list of scalars, optional</span>
<span class="sd">        The amount of overlap to include when dividing up the image. This</span>
<span class="sd">        value will almost always be the size (i.e. raduis) of the</span>
<span class="sd">        structuring element. If not specified then the amount of overlap</span>
<span class="sd">        is inferred from the size of the structuring element, in which</span>
<span class="sd">        case the ``strel_arg`` must be specified.</span>
<span class="sd">    divs : scalar or list of scalars (default = [2, 2, 2])</span>
<span class="sd">        The number of chunks to divide the image into in each direction.</span>
<span class="sd">        The default is 2 chunks in each direction, resulting in a</span>
<span class="sd">        quartering of the image and 8 total chunks (in 3D).  A scalar is</span>
<span class="sd">        interpreted as applying to all directions, while a list of scalars</span>
<span class="sd">        is interpreted as applying to each individual direction.</span>
<span class="sd">    cores : scalar</span>
<span class="sd">        The number of cores which should be used.  By default, all cores</span>
<span class="sd">        will be used, or as many are needed for the given number of</span>
<span class="sd">        chunks, which ever is smaller.</span>
<span class="sd">    im_arg : str</span>
<span class="sd">        The keyword used by ``func`` for the image to be operated on. By</span>
<span class="sd">        default this function will look for ``image``, ``input``, and</span>
<span class="sd">        ``im`` which are commonly used by *scipy.ndimage* and *skimage*.</span>
<span class="sd">    strel_arg : str</span>
<span class="sd">        The keyword used by ``func`` for the structuring element to apply.</span>
<span class="sd">        This is only needed if ``overlap`` is not specified. By default</span>
<span class="sd">        this function will look for ``strel``, ``structure``, and</span>
<span class="sd">        ``footprint`` which are commonly used by *scipy.ndimage* and</span>
<span class="sd">        *skimage*.</span>
<span class="sd">    kwargs</span>
<span class="sd">        All other arguments are passed to ``func`` as keyword arguments.</span>
<span class="sd">        Note that PoreSpy will fetch the image from this list of keywords</span>
<span class="sd">        using the value provided to ``im_arg``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : ndarray</span>
<span class="sd">        An image the same size as the input image, with the specified</span>
<span class="sd">        filter applied as though done on a single large image. There</span>
<span class="sd">        should be *no* difference.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function divides the image into the specified number of chunks,</span>
<span class="sd">    but also applies a padding to each chunk to create an overlap with</span>
<span class="sd">    neighboring chunks. This way the operation does not have any edge</span>
<span class="sd">    artifacts. The amount of padding is usually equal to the radius of the</span>
<span class="sd">    structuring element but some functions do not use one, such as the</span>
<span class="sd">    distance transform and Gaussian blur.  In these cases the user can</span>
<span class="sd">    specify ``overlap``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    scikit-image.util.apply_parallel</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    `Click here</span>
<span class="sd">    &lt;https://porespy.org/examples/filters/reference/chunked_func.html&gt;`_</span>
<span class="sd">    to view online example.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@dask</span><span class="o">.</span><span class="n">delayed</span>
    <span class="k">def</span> <span class="nf">apply_func</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Apply function on sub-slice of overall image</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># Determine the value for im_arg</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">im_arg</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">im_arg</span> <span class="o">=</span> <span class="p">[</span><span class="n">im_arg</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">im_arg</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">im</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
            <span class="n">im_arg</span> <span class="o">=</span> <span class="n">item</span>
            <span class="k">break</span>
    <span class="c1"># Fetch image from the kwargs dict</span>
    <span class="n">im</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">im_arg</span><span class="p">]</span>
    <span class="c1"># Determine the number of divisions to create</span>
    <span class="n">divs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">im</span><span class="o">.</span><span class="n">ndim</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">divs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cores</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cores</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">ncores</span>
    <span class="c1"># If overlap given then use it, otherwise search for strel in kwargs</span>
    <span class="k">if</span> <span class="n">overlap</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">overlap</span> <span class="o">=</span> <span class="n">overlap</span> <span class="o">*</span> <span class="p">(</span><span class="n">divs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">strel_arg</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">strel_arg</span> <span class="o">=</span> <span class="p">[</span><span class="n">strel_arg</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">strel_arg</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">strel</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
                <span class="k">break</span>
        <span class="n">overlap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">strel</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">divs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">slices</span> <span class="o">=</span> <span class="n">subdivide</span><span class="p">(</span><span class="n">im</span><span class="o">=</span><span class="n">im</span><span class="p">,</span> <span class="n">divs</span><span class="o">=</span><span class="n">divs</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="n">overlap</span><span class="p">)</span>
    <span class="c1"># Apply func to each subsection of the image</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">slices</span><span class="p">:</span>
        <span class="c1"># Extract subsection from image and input into kwargs</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="n">im_arg</span><span class="p">]</span> <span class="o">=</span> <span class="n">dask</span><span class="o">.</span><span class="n">delayed</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">im</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">s</span><span class="p">)]))</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">apply_func</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
    <span class="c1"># Have dask actually compute the function on each subsection in parallel</span>
    <span class="c1"># with ProgressBar():</span>
        <span class="c1"># ims = dask.compute(res, num_workers=cores)[0]</span>
    <span class="n">ims</span> <span class="o">=</span> <span class="n">dask</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">num_workers</span><span class="o">=</span><span class="n">cores</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># Finally, put the pieces back together into a single master image, im2</span>
    <span class="n">im2</span> <span class="o">=</span> <span class="n">recombine</span><span class="p">(</span><span class="n">ims</span><span class="o">=</span><span class="n">ims</span><span class="p">,</span> <span class="n">slices</span><span class="o">=</span><span class="n">slices</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="n">overlap</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">im2</span></div>
</pre></div>

              </article>
              

              
          </div>
          
      </div>
    </div>

  
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=92025949c220c2e29695"></script>

<footer class="bd-footer"><div class="bd-footer__inner container">
  
  <div class="footer-item">
    <p class="copyright">
    &copy; Copyright 2023, PMEAL.<br>
</p>
  </div>
  
  <div class="footer-item">
    <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 5.3.0.<br>
</p>
  </div>
  
</div>
</footer>
  </body>
</html>